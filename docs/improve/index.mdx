---
title: 进阶篇
---

# {frontmatter.title}

## 1、数据类型及检测方式

> 1. 基本数据类型：`Number`、`String`、`Boolean`、`Null`、`Undefined`、`Symbol`、`BigInt`
> 2. 引用数据类型：`Object`、`Array`、`Function`、`Date`、`RegExp`、`Error`

- **原始数据类型**：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。
- **引用数据类型**：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

```js title="变量引用--题目训练"
let a = {
  name: 'Julia',
  age: 20,
};

functionchange(o) {
  o.age = 24;
  o = {
    name: 'Kath',
    age: 30,
  };
  return o;
}
let b = change(a);
console.log(a.age); // 24
console.log(b.age); // 30
```

### 1.1、typeof

```js title="typeof 对于原始类型来说，除了 null 都可以显示正确的类型"
typeof 123; // "number"
typeof "123"; // "string"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof Symbol(); // "symbol"
typeof BigInt(123); // "bigint"
typeof null; // "object" 这里是一个历史遗留问题，null 本身是基本类型，但是 typeof null 返回的是 object
```

### 1.2、instanceof

> `instanceof`可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

```js title="instanceof 用于判断一个变量是否为某个对象的实例"
// 基本包装类型
console.log(2 instanceof Number); // false
console.log(new Number(2) instanceof Number); // true

console.log(true instanceof Boolean); // false
console.log(new Boolean(true) instanceof Boolean); // true

console.log("str" instanceof String); // false
console.log(new String("str") instanceof String); // true

console.log([] instanceof Array); // true
console.log(function () {} instanceof Function); // true
console.log({} instanceof Object); // true

// Null 和 Undefined 不能使用 instanceof
// console.log(null instanceof Null); // Null in not defined
// console.log(undefined instanceof Undefined); // Undefined in not defined

// 我们尝试着自己实现一下 instanceof 加上注释
function myInstanceof(left, right) {
  // 获取类型的原型
  let prototype = right.prototype;
  // 获取对象的原型
  left = left.__proto__;
  // 判断对象的类型是否等于类型的原型
  while (true) {
    if (left === null) return false;
    if (left === prototype) return true;
    left = left.__proto__;
    // 这里为什么要重新赋值呢？
    // 因为我们要一直向上查找 left 的原型链
    // 直到找到 prototype 为止 如果找不到就返回 false 了
    // 这里的 left 就是上一次的 left.__proto__ 也就是上一次的原型
    // 一直循环下去 直到找到为止 或者找不到为止
  }
}
```

### 1.3、constructor

```js
console.log((2).constructor === Number); // true
console.log(true.constructor === Boolean); // true
console.log("str".constructor === String); // true
console.log([].constructor === Array); // true
console.log(function () {}.constructor === Function); // true
console.log({}.constructor === Object); // true
```

### 1.4、Object.prototype.toString.call()

```js
// 引用类型
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"
Object.prototype.toString.call(/123/g); // "[object RegExp]"
Object.prototype.toString.call(new Date()); // "[object Date]"
Object.prototype.toString.call(document); // "[object HTMLDocument]"
Object.prototype.toString.call(window); // "[object Window]"
// 基础类型
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call("str"); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(Symbol()); // "[object Symbol]"
Object.prototype.toString.call(BigInt(123)); // "[object BigInt]"
```

> 在`js`中，类型转换只有三种情况
>
> 1. 转换为`Boolean`类型
> 2. 转换为`Number`类型
> 3. 转换为`String`类型

**转换为 Boolean**

> 在条件判断时，除了`undefined`、`null`、`false`、`+0`、`-0`、`NaN`、`''`，其他都会转换为`true`。包括所有对象

```js
Boolean(0); // false
Boolean(NaN); // false
Boolean(""); // false
Boolean(null); // false
Boolean(undefined); // false
Boolean(false); // false
Boolean(+0); // false
Boolean(-0); // false

// 其他都是 true
Boolean({}); // true
Boolean([]); // true
Boolean(function () {}); // true
Boolean(Symbol()); // true
Boolean(BigInt(123)); // true
```

**对象转原始类型**

> 对象在转换类型的时候，会调用内置的`[[ToPrimitive]]`函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了，直接返回
- 调用 `x.valueOf()`，如果转换为基础类型，就返回转换的值
- 调用 `x.toString()`，如果转换为基础类型，就返回转换的值
- 如果都没有返回基础类型，就报错

> 当然你也可以重写`Symbol.toPrimitive`方法，该方法在转原始类型时调用优先级最高

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return "1";
  },
  [Symbol.toPrimitive]() {
    return 2;
  },
};
```
